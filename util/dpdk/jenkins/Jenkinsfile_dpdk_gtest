#! /usr/bin/env groovy

def get_changes_string() {
    MAX_MSG_LEN = 100

    def change_sets = currentBuild.changeSets.unique()
    if (change_sets.size() == 0) {
        return " - No new changes"
    }

    def change_string = ""
    for (entry in change_sets[0].items) {
        change_string += "${entry.commitId} [${entry.author}]:<br/>- ${entry.msg}<br/>"
    }

    return change_string
}

def run_as_sudo(shell_command) {
    sh 'echo "!2023!cns!xhd!sw!" | sudo -S ' + shell_command
}

def reboot_target(target_hostname) {

    try {
        timeout(20) { //minutes
            // assume running on master node
            run_as_sudo("ssh -t -o StrictHostKeyChecking=no -l icons_cadman ${target_hostname} /usr/bin/sudo -S /sbin/reboot") //schedule reboot in 1 min
        }
    } catch (e) {
        sleep 200 // seconds, give some time for reboot
        waitUntil { // wait until ssh port is open
            def ret = sh script: "nc -w 20 -z ${target_hostname} 22 > /dev/null", returnStatus: true
            return (ret == 0)
        }
    }

        node(target_hostname) { // confirm jenkins slave is up
            sh 'uptime; echo $(hostname) ONLINE'
        }
}

def ignore_error(func, err_msg = "ignored error") {
    try {
        func()
    } catch (err) {
        echo "$err_msg"
    }
}

def send_build_result_email(recipients) {
    mail(to: "${recipients}",
        mimeType: 'text/html',
        from: 'jenkinsrobot@xilinx.com',
        subject: "${currentBuild.fullDisplayName}: ${currentBuild.currentResult}",
        body: """<p>Project: ${currentBuild.fullDisplayName}<br/>
                Result: ${currentBuild.currentResult}<br/>
                Bitfile: ${BITFILE}<br/>
                Changes:<br/>
                ${get_changes_string()}<br/>
                <br/>
                For more details please go to <a href=${env.JOB_URL}>${env.JOB_NAME}</a></p>""");
}

// Jenkin's JTest processor requires that a skipped test contains the <skipped> element and not just setting status to "notrun":
def reformat_test_results(test_results_file) {
    sh """awk '{ if (\$1 == "<testcase" && match(\$0, "notrun")) print substr(\$0,0,length(\$0)-2) "><skipped/></testcase>"; else print \$0;}' ${test_results_file} > tmp.xml"""
    sh "rm -f ${test_results_file}"
    sh "mv tmp.xml ${test_results_file}"
}

pipeline {
    agent { node { label 'master' } }
    options {
        disableConcurrentBuilds()
        skipDefaultCheckout(true)
    }
    stages {

		stage('checkout') { steps { //
            		node("${NODE_ADDRESS}")  {
                //deleteDir()
                	checkout scm
            		}
        	}}

		  stage('envsetup') { steps { script {//
            node("${NODE_ADDRESS}")  {
			echo "update the grub"
			if ("$BIND_DRV" == "vfio-pci") {
				run_as_sudo('cp /etc/default/grub-dpdk-vfio-pci /etc/default/grub')
			} else {
				run_as_sudo('cp /etc/default/grub-dpdk-igb-uio /etc/default/grub')
			}
				run_as_sudo('update-grub')
				run_as_sudo('update-grub2')
            }
        }}}


        	stage('deploy') { steps {
            		node("${NODE_ADDRESS}")  {
                		echo "uploading bitstream..."
                		dir('.') { script {
                    			bitfile_dir ="${env.WORKSPACE}/${BITFILE}"
                    			echo "${bitfile_dir}" // BITFILE can be set via jenkins job parameter
                    			if ("$DEVICETYPE" == "VERSAL") {
                    				run_as_sudo('sh util/common/scripts/program_versal_pdi.sh ${TARGET_ID} util/common/scripts/spi2vjtag.tcl ${BITFILE} util/common/scripts/qdma_versal_mm_st_4pf_252vf.tcl util/common/scripts/qdma_versal_msix.tcl')
                    			}
                    			else {
									run_as_sudo('sh util/common/scripts/program_qdma_bitstream.sh ${TARGET_ID} ${BITFILE}')
									//run_as_sudo('/proj/xbuilds/2018.2_daily_latest/installs/lin64/Vivado/2018.2/bin/vivado -nolog -nojournal -mode batch -source util/common/scripts/program_bitstream.tcl -tclargs ${TARGET_ID} 0 ${BITFILE}')
                    			}
                		}}
            		}

            		script { // on master node
            			echo "rebooting target machine..."
				reboot_target("${NODE_ADDRESS}")
            		}

			node("${NODE_ADDRESS}")  { script {
				    echo "Starting Test Execution"
				    dir("${SCRIPT_PATH}") {

					run_as_sudo('chmod +x ./*.sh')
					run_as_sudo('chmod +x ./*.py')
					run_as_sudo('./gtest_top.sh ${PCI_BBDDF} ../../../../${GTEST_CONFIG_DIR} ../../../../${DRIVER_PATH} ../../../../${TEST_APP_PATH} pf_vf dpdk ${CONFIG_BAR} ${BIND_DRV} ${COMPILE_FLAGS}')
					}
					ignore_error({run_as_sudo('chmod 0777 ${TEST_APP_PATH}/build_dpdk_pf_vf/ -R ')})
				    ignore_error({run_as_sudo('chmod 0777 ${TEST_APP_PATH}/logs/ -R ')})
				    ignore_error({run_as_sudo('chown -R icons_cadman:shine_icons ${TEST_APP_PATH}/* ')})

				    echo "Archiving build products..."
				    archiveArtifacts artifacts: "${TEST_APP_PATH}/build_dpdk_pf_vf/src/qdma_test", fingerprint: true
				    archiveArtifacts artifacts: "${TEST_APP_PATH}/build_dpdk_pf_vf/*.xlsx", fingerprint: true
				    archiveArtifacts artifacts: "${TEST_APP_PATH}/logs/*.txt", fingerprint: true
			    }
			}
        	}}
   	}
	post {

        always { script {
            // EMAIL_RECIPIENTS can be set via jenkins job parameter
            echo "Emailing build results to: ${EMAIL_RECIPIENTS}"
            send_build_result_email("${EMAIL_RECIPIENTS}")
        }}

        cleanup {
		node("${NODE_ADDRESS}") { script {
             echo "restore grub entry"

			 ignore_error({run_as_sudo('rm -rf /mnt/huge/*')})
			run_as_sudo('cp /etc/default/grub-default /etc/default/grub')
			run_as_sudo('update-grub')
			run_as_sudo('update-grub2')

                }
             }
        }
    }
}
