diff --git a/app/test-pmd/cmdline.c b/app/test-pmd/cmdline.c
index b32dc8b..7ffc5c0 100755
--- a/app/test-pmd/cmdline.c
+++ b/app/test-pmd/cmdline.c
@@ -12550,6 +12550,151 @@ struct cmd_showport_macs_result {
 	},
 };
 
+/* *** display rx/tx descriptor status *** */
+struct cmd_show_descriptor_status_result {
+	cmdline_fixed_string_t cmd_show;
+	uint16_t port_id;
+	cmdline_fixed_string_t queue_dir;
+	uint16_t queue_id;
+	uint16_t descriptor_offset;
+};
+
+static void
+cmd_show_descriptor_status_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_show_descriptor_status_result *res = parsed_result;
+	uint8_t is_rx = 0;
+	int ret;
+
+	if (!rte_eth_dev_is_valid_port(res->port_id)) {
+		printf("invalid port id %u\n", res->port_id);
+		return;
+	}
+
+	if (!strcmp(res->queue_dir, "rx")) {
+		is_rx = 1;
+	} else if (!strcmp(res->queue_dir, "tx")) {
+		is_rx = 0;
+	} else {
+		printf("invalid queue direction: %s\n", res->queue_dir);
+		return;																				}
+
+	if (is_rx) {
+		ret = rte_eth_rx_descriptor_status(res->port_id,
+				res->queue_id, res->descriptor_offset);
+		if (ret < 0) {
+			printf("Error getting Rx queue %d descriptor %d status: %d\n",
+					res->queue_id, res->descriptor_offset, ret);
+		} else {
+			printf("Port: %d, Rx queue: %d, descriptor offset: %d, status: %s\n",
+					res->port_id, res->queue_id, res->descriptor_offset,
+					(ret) ? ((ret == 1) ? "RTE_ETH_RX_DESC_DONE" : "RTE_ETH_RX_DESC_UNAVAIL") : "RTE_ETH_RX_DESC_AVAIL");
+		}
+	} else {
+		ret = rte_eth_tx_descriptor_status(res->port_id,
+				res->queue_id, res->descriptor_offset);
+		if (ret < 0) {
+			printf("Error getting Tx queue %d descriptor %d status: %d\n",
+					res->queue_id, res->descriptor_offset, ret);
+		} else {
+			printf("Port: %d, Tx queue: %d, descriptor offset: %d, status: %s\n",
+					res->port_id, res->queue_id, res->descriptor_offset,
+					(ret) ? ((ret == 1) ? "RTE_ETH_TX_DESC_DONE" : "RTE_ETH_TX_DESC_UNAVAIL") : "RTE_ETH_TX_DESC_FULL");
+
+		}
+	}
+}
+
+cmdline_parse_token_string_t cmd_show_descriptor_status_show =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_descriptor_status_result,
+			cmd_show, "show");
+cmdline_parse_token_num_t cmd_show_descriptor_status_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			port_id, RTE_UINT16);
+cmdline_parse_token_string_t cmd_show_descriptor_status_queue_dir =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_descriptor_status_result,
+			queue_dir, "rx#tx");
+cmdline_parse_token_num_t cmd_show_descriptor_status_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			queue_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_show_descriptor_status_descriptor_offset =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			descriptor_offset, RTE_UINT16);
+
+cmdline_parse_inst_t cmd_show_descriptor_status = {
+		.f = cmd_show_descriptor_status_parsed,
+		.data = NULL,
+		.help_str = "show <port_id> tx|rx <queue_id> <descriptor_offset>",
+		.tokens = {
+			(void *)&cmd_show_descriptor_status_show,
+			(void *)&cmd_show_descriptor_status_port_id,
+			(void *)&cmd_show_descriptor_status_queue_dir,
+			(void *)&cmd_show_descriptor_status_queue_id,
+			(void *)&cmd_show_descriptor_status_descriptor_offset,
+			NULL,
+		},
+};
+
+/* *** Tx cleanup *** */
+struct cmd_cleanup_tx_done_result {
+	cmdline_fixed_string_t cmd_cleanup_tx;
+	uint16_t port_id;
+	uint16_t queue_id;
+	uint16_t free_cnt;
+};
+
+static void
+cmd_cleanup_tx_done_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_cleanup_tx_done_result *res = parsed_result;
+	int ret;
+
+	if (!rte_eth_dev_is_valid_port(res->port_id)) {
+		printf("invalid port id %u\n", res->port_id);
+		return;
+	}
+
+	ret = rte_eth_tx_done_cleanup(res->port_id,
+			res->queue_id, res->free_cnt);
+	if (ret < 0) {
+		printf("Error freeing up Tx queue %d descriptors: %d\n",
+				res->queue_id, ret);
+	} else {
+		printf("Port: %d, Tx queue: %d, freed count: %d\n",
+				res->port_id, res->queue_id, ret);
+	}
+}
+
+cmdline_parse_token_string_t cmd_cleanup_tx_done_cmd_cleanup_tx =
+	TOKEN_STRING_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			cmd_cleanup_tx, "cleanup_tx");
+cmdline_parse_token_num_t cmd_cleanup_tx_done_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			port_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_cleanup_tx_done_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			queue_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_cleanup_tx_done_free_cnt =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			free_cnt, RTE_UINT16);
+
+cmdline_parse_inst_t cmd_cleanup_tx_done = {
+		.f = cmd_cleanup_tx_done_parsed,
+		.data = NULL,
+		.help_str = "cleanup_tx <port_id> <queue_id> <free_cnt>",
+		.tokens = {
+			(void *)&cmd_cleanup_tx_done_cmd_cleanup_tx,
+			(void *)&cmd_cleanup_tx_done_port_id,
+			(void *)&cmd_cleanup_tx_done_queue_id,
+			(void *)&cmd_cleanup_tx_done_free_cnt,
+			NULL,
+		},
+};
+
 /* *** show flow transfer proxy port ID for the given port *** */
 struct cmd_show_port_flow_transfer_proxy_result {
 	cmdline_fixed_string_t show;
@@ -12844,6 +12989,8 @@ struct cmd_show_port_flow_transfer_proxy_result {
 	(cmdline_parse_inst_t *)&cmd_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw_all,
+	(cmdline_parse_inst_t *)&cmd_show_descriptor_status,
+	(cmdline_parse_inst_t *)&cmd_cleanup_tx_done,	
 	(cmdline_parse_inst_t *)&cmd_config_tx_dynf_specific,
 	(cmdline_parse_inst_t *)&cmd_show_fec_mode,
 	(cmdline_parse_inst_t *)&cmd_set_fec_mode,
diff --git a/app/test-pmd/config.c b/app/test-pmd/config.c
index acccb6b..5938a56 100755
--- a/app/test-pmd/config.c
+++ b/app/test-pmd/config.c
@@ -282,12 +282,20 @@
 	uint64_t mpps_rx, mpps_tx, mbps_rx, mbps_tx;
 	struct rte_eth_stats stats;
 	static const char *nic_stats_border = "########################";
-	int ret;
+	int ret,i;
 
 	if (port_id_is_invalid(port_id, ENABLED_WARN)) {
 		print_valid_ports();
 		return;
 	}
+	struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+	for (i = 0; i < dev->data->nb_rx_queues; i++) {
+		ret = rte_eth_rx_queue_count(port_id, i);
+		if (ret < 0)
+			printf("Error %d retrieving Rx queue count for queue %d\n", ret, i);
+		else
+			printf("Rx queue: %d\t Num descriptors used = %d\n", i, ret);
+	}	
 	ret = rte_eth_stats_get(port_id, &stats);
 	if (ret != 0) {
 		fprintf(stderr,
diff --git a/app/test-pmd/testpmd.c b/app/test-pmd/testpmd.c
index 134d79a..c2afbb7 100755
--- a/app/test-pmd/testpmd.c
+++ b/app/test-pmd/testpmd.c
@@ -74,6 +74,7 @@
 #endif
 
 #include "testpmd.h"
+#include <ethdev_driver.h>
 
 #ifndef MAP_HUGETLB
 /* FreeBSD may not have MAP_HUGETLB (in fact, it probably doesn't) */
@@ -3617,9 +3618,11 @@ struct extmem_param {
 void
 pmd_test_exit(void)
 {
-	portid_t pt_id;
+    struct rte_device *device;
+    int pt_id;
 	unsigned int i;
 	int ret;
+    uint32_t nb_ports;
 
 	if (test_done == 0)
 		stop_packet_forwarding();
@@ -3635,15 +3638,20 @@ struct extmem_param {
 #endif
 	if (ports != NULL) {
 		no_link_check = 1;
-		RTE_ETH_FOREACH_DEV(pt_id) {
+        nb_ports = rte_eth_dev_count_avail();
+        for(pt_id = nb_ports-1; pt_id >= 0; pt_id--) {
 			printf("\nStopping port %d...\n", pt_id);
 			fflush(stdout);
 			stop_port(pt_id);
 		}
-		RTE_ETH_FOREACH_DEV(pt_id) {
+        for(pt_id = nb_ports-1; pt_id >= 0; pt_id--) {
 			printf("\nShutting down port %d...\n", pt_id);
 			fflush(stdout);
 			close_port(pt_id);
+            device = rte_eth_devices[pt_id].device;
+            if (device && (!strcmp(device->driver->name, "net_qdma") ||
+                            !strcmp(device->driver->name, "net_qdma_vf")))
+                    detach_port_device(pt_id);
 		}
 	}
 
