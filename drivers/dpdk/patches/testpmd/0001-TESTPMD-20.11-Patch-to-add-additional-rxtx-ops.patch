From dcf1da804989fc3184609a7e718a2d245ab22738 Mon Sep 17 00:00:00 2001
From: tarakr <tarakr@xilinx.com>
Date: Mon, 23 Mar 2020 20:17:14 +0530
Subject: [PATCH] TESTPMD-20.11-Patch to remove device at exit

Signed-off-by: tarakr <tarakr@xilinx.com>
Signed-off-by: Suryanarayana Raju Sangani <ssangani@xilinx.com>
---
 app/test-pmd/cmdline.c | 146 +++++++++++++++++++++++++++++++++++++++++
 app/test-pmd/config.c  |   9 +++
 app/test-pmd/testpmd.c |  15 ++++-
 3 files changed, 167 insertions(+), 3 deletions(-)

diff --git a/app/test-pmd/cmdline.c b/app/test-pmd/cmdline.c
index 0d2d6aa..8843d27 100644
--- a/app/test-pmd/cmdline.c
+++ b/app/test-pmd/cmdline.c
@@ -16810,6 +16810,150 @@ cmdline_parse_inst_t cmd_showport_macs = {
 	},
 };
 
+/* *** display rx/tx descriptor status *** */
+struct cmd_show_descriptor_status_result {
+	cmdline_fixed_string_t cmd_show;
+	uint16_t port_id;
+	cmdline_fixed_string_t queue_dir;
+	uint16_t queue_id;
+	uint16_t descriptor_offset;
+};
+
+static void
+cmd_show_descriptor_status_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_show_descriptor_status_result *res = parsed_result;
+	uint8_t is_rx = 0;
+	int ret;
+
+	if (!rte_eth_dev_is_valid_port(res->port_id)) {
+		printf("invalid port id %u\n", res->port_id);
+		return;
+	}
+
+	if (!strcmp(res->queue_dir, "rx")) {
+		is_rx = 1;
+	} else if (!strcmp(res->queue_dir, "tx")) {
+		is_rx = 0;
+	} else {
+		printf("invalid queue direction: %s\n", res->queue_dir);
+		return;																				}
+
+	if (is_rx) {
+		ret = rte_eth_rx_descriptor_status(res->port_id,
+				res->queue_id, res->descriptor_offset);
+		if (ret < 0) {
+			printf("Error getting Rx queue %d descriptor %d status: %d\n",
+					res->queue_id, res->descriptor_offset, ret);
+		} else {
+			printf("Port: %d, Rx queue: %d, descriptor offset: %d, status: %s\n",
+					res->port_id, res->queue_id, res->descriptor_offset,
+					(ret) ? ((ret == 1) ? "RTE_ETH_RX_DESC_DONE" : "RTE_ETH_RX_DESC_UNAVAIL") : "RTE_ETH_RX_DESC_AVAIL");
+		}
+	} else {
+		ret = rte_eth_tx_descriptor_status(res->port_id,
+				res->queue_id, res->descriptor_offset);
+		if (ret < 0) {
+			printf("Error getting Tx queue %d descriptor %d status: %d\n",
+					res->queue_id, res->descriptor_offset, ret);
+		} else {
+			printf("Port: %d, Tx queue: %d, descriptor offset: %d, status: %s\n",
+					res->port_id, res->queue_id, res->descriptor_offset,
+					(ret) ? ((ret == 1) ? "RTE_ETH_TX_DESC_DONE" : "RTE_ETH_TX_DESC_UNAVAIL") : "RTE_ETH_TX_DESC_FULL");
+
+		}
+	}
+}
+
+cmdline_parse_token_string_t cmd_show_descriptor_status_show =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_descriptor_status_result,
+			cmd_show, "show");
+cmdline_parse_token_num_t cmd_show_descriptor_status_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			port_id, RTE_UINT16);
+cmdline_parse_token_string_t cmd_show_descriptor_status_queue_dir =
+	TOKEN_STRING_INITIALIZER(struct cmd_show_descriptor_status_result,
+			queue_dir, "rx#tx");
+cmdline_parse_token_num_t cmd_show_descriptor_status_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			queue_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_show_descriptor_status_descriptor_offset =
+	TOKEN_NUM_INITIALIZER(struct cmd_show_descriptor_status_result,
+			descriptor_offset, RTE_UINT16);
+
+cmdline_parse_inst_t cmd_show_descriptor_status = {
+		.f = cmd_show_descriptor_status_parsed,
+		.data = NULL,
+		.help_str = "show <port_id> tx|rx <queue_id> <descriptor_offset>",
+		.tokens = {
+			(void *)&cmd_show_descriptor_status_show,
+			(void *)&cmd_show_descriptor_status_port_id,
+			(void *)&cmd_show_descriptor_status_queue_dir,
+			(void *)&cmd_show_descriptor_status_queue_id,
+			(void *)&cmd_show_descriptor_status_descriptor_offset,
+			NULL,
+		},
+};
+
+/* *** Tx cleanup *** */
+struct cmd_cleanup_tx_done_result {
+	cmdline_fixed_string_t cmd_cleanup_tx;
+	uint16_t port_id;
+	uint16_t queue_id;
+	uint16_t free_cnt;
+};
+
+static void
+cmd_cleanup_tx_done_parsed(void *parsed_result,
+		__attribute__((unused)) struct cmdline *cl,
+		__attribute__((unused)) void *data)
+{
+	struct cmd_cleanup_tx_done_result *res = parsed_result;
+	int ret;
+
+	if (!rte_eth_dev_is_valid_port(res->port_id)) {
+		printf("invalid port id %u\n", res->port_id);
+		return;
+	}
+
+	ret = rte_eth_tx_done_cleanup(res->port_id,
+			res->queue_id, res->free_cnt);
+	if (ret < 0) {
+		printf("Error freeing up Tx queue %d descriptors: %d\n",
+				res->queue_id, ret);
+	} else {
+		printf("Port: %d, Tx queue: %d, freed count: %d\n",
+				res->port_id, res->queue_id, ret);
+	}
+}
+
+cmdline_parse_token_string_t cmd_cleanup_tx_done_cmd_cleanup_tx =
+	TOKEN_STRING_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			cmd_cleanup_tx, "cleanup_tx");
+cmdline_parse_token_num_t cmd_cleanup_tx_done_port_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			port_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_cleanup_tx_done_queue_id =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			queue_id, RTE_UINT16);
+cmdline_parse_token_num_t cmd_cleanup_tx_done_free_cnt =
+	TOKEN_NUM_INITIALIZER(struct cmd_cleanup_tx_done_result,
+			free_cnt, RTE_UINT16);
+
+cmdline_parse_inst_t cmd_cleanup_tx_done = {
+		.f = cmd_cleanup_tx_done_parsed,
+		.data = NULL,
+		.help_str = "cleanup_tx <port_id> <queue_id> <free_cnt>",
+		.tokens = {
+			(void *)&cmd_cleanup_tx_done_cmd_cleanup_tx,
+			(void *)&cmd_cleanup_tx_done_port_id,
+			(void *)&cmd_cleanup_tx_done_queue_id,
+			(void *)&cmd_cleanup_tx_done_free_cnt,
+			NULL,
+		},
+};
 /* ******************************************************************************** */
 
 /* list of instructions */
@@ -17080,6 +17224,8 @@ cmdline_parse_ctx_t main_ctx[] = {
 	(cmdline_parse_inst_t *)&cmd_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw,
 	(cmdline_parse_inst_t *)&cmd_show_set_raw_all,
+	(cmdline_parse_inst_t *)&cmd_show_descriptor_status,
+	(cmdline_parse_inst_t *)&cmd_cleanup_tx_done,
 	(cmdline_parse_inst_t *)&cmd_config_tx_dynf_specific,
 	(cmdline_parse_inst_t *)&cmd_show_fec_mode,
 	(cmdline_parse_inst_t *)&cmd_set_fec_mode,
diff --git a/app/test-pmd/config.c b/app/test-pmd/config.c
index b51de59..ff6b7b8 100644
--- a/app/test-pmd/config.c
+++ b/app/test-pmd/config.c
@@ -192,6 +192,15 @@ nic_stats_display(portid_t port_id)
 		print_valid_ports();
 		return;
 	}
+	struct rte_eth_dev *dev = &rte_eth_devices[port_id];
+	int ret;
+	for (i = 0; i < dev->data->nb_rx_queues; i++) {
+		ret = rte_eth_rx_queue_count(port_id, i);
+		if (ret < 0)
+			printf("Error %d retrieving Rx queue count for queue %d\n", ret, i);
+		else
+			printf("Rx queue: %d\t Num descriptors used = %d\n", i, ret);
+	}
 	rte_eth_stats_get(port_id, &stats);
 	printf("\n  %s NIC statistics for port %-2d %s\n",
 	       nic_stats_border, port_id, nic_stats_border);
diff --git a/app/test-pmd/testpmd.c b/app/test-pmd/testpmd.c
index 33fc0fd..905d497 100644
--- a/app/test-pmd/testpmd.c
+++ b/app/test-pmd/testpmd.c
@@ -3088,9 +3088,11 @@ detach_devargs(char *identifier)
 void
 pmd_test_exit(void)
 {
-	portid_t pt_id;
+	struct rte_device *device;
+	int pt_id;
 	unsigned int i;
 	int ret;
+	uint32_t nb_ports;
 
 	if (test_done == 0)
 		stop_packet_forwarding();
@@ -3104,15 +3106,22 @@ pmd_test_exit(void)
 	}
 	if (ports != NULL) {
 		no_link_check = 1;
-		RTE_ETH_FOREACH_DEV(pt_id) {
+		nb_ports = rte_eth_dev_count_avail();
+		for(pt_id = nb_ports-1; pt_id >= 0; pt_id--) {
 			printf("\nStopping port %d...\n", pt_id);
 			fflush(stdout);
 			stop_port(pt_id);
 		}
-		RTE_ETH_FOREACH_DEV(pt_id) {
+		for(pt_id = nb_ports-1; pt_id >= 0; pt_id--) {
 			printf("\nShutting down port %d...\n", pt_id);
 			fflush(stdout);
 			close_port(pt_id);
+
+			device = rte_eth_devices[pt_id].device;
+			if (device && (!strcmp(device->driver->name, "net_qdma") ||
+					!strcmp(device->driver->name, "net_qdma_vf")))
+				detach_port_device(pt_id);
+
 		}
 	}
 
-- 
2.17.1

