From 9d14a7569e9fb7cca61f728d315f65e63073646e Mon Sep 17 00:00:00 2001
From: Suryanarayana Raju Sangani <ssangani@xilinx.com>
Date: Thu, 27 Feb 2020 23:36:43 -0700
Subject: [PATCH] Add QDMA xdebug to proc-info of dpdk-20.11

Signed-off-by: Nikhil agarwal <nagarwal@xilinx.com>
Signed-off-by: Thanneeru Srinivasulu <sthannee@xilinx.com>
Signed-off-by: Sangani Suryanarayana Raju <ssangani@xilinx.com>
---
 app/proc-info/main.c | 172 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 165 insertions(+), 7 deletions(-)

diff --git a/app/proc-info/main.c b/app/proc-info/main.c
index d743209..09a6eac 100644
--- a/app/proc-info/main.c
+++ b/app/proc-info/main.c
@@ -30,6 +30,7 @@
 #include <rte_branch_prediction.h>
 #include <rte_string_fns.h>
 #include <rte_metrics.h>
+#include <rte_pmd_qdma.h>
 #include <rte_cycles.h>
 #ifdef RTE_LIB_SECURITY
 #include <rte_security.h>
@@ -47,9 +48,27 @@
 	STATS_BDR_FMT, s, w, STATS_BDR_FMT)
 
 /**< mask of enabled ports */
-static unsigned long enabled_port_mask;
+static uint64_t enabled_port_mask;
+/**< QID for queue context */
+static uint32_t qid;
+/**< desc dump type */
+static uint32_t desc_type;
+/**< QID for desc start value */
+static uint32_t start;
+/**< QID for desc end value */
+static uint32_t end;
+/**< Enable desc dump. */
+static uint32_t enable_desc_dump;
 /**< Enable stats. */
 static uint32_t enable_stats;
+/**< Enable Device Structs */
+static uint32_t qdma_device;
+/**< Enable Queue context and Queue structs. */
+static uint32_t queue_info;
+/**< Enable register field information. */
+static uint32_t reg_info;
+/**< Register address */
+static uint32_t reg_addr;
 /**< Enable xstats. */
 static uint32_t enable_xstats;
 /**< Enable collectd format*/
@@ -66,6 +85,8 @@ static uint32_t reset_stats;
 static uint32_t reset_xstats;
 /**< Enable memory info. */
 static uint32_t mem_info;
+/**< Enable Global Errors . */
+static uint32_t qdma_csr_info;
 /**< Enable displaying xstat name. */
 static uint32_t enable_xstats_name;
 static char *xstats_name;
@@ -100,8 +121,13 @@ proc_info_usage(const char *prgname)
 {
 	printf("%s [EAL options] -- -p PORTMASK\n"
 		"  -m to display DPDK memory zones, segments and TAILQ information\n"
+		"  -g to display DPDK QDMA PMD global CSR info\n"
 		"  -p PORTMASK: hexadecimal bitmask of ports to retrieve stats for\n"
 		"  --stats: to display port statistics, enabled by default\n"
+		"  --qdevice: to display QDMA device structure\n"
+		"  --qinfo: to display QDMA queue context and queue structures\n"
+		"  --reg-info {reg_addr}: to display field info of a register at reg_addr offset\n"
+		"  --desc-dump {rx | tx | cmpt}: to dump QDMA queue descriptors\n"
 		"  --xstats: to display extended port statistics, disabled by "
 			"default\n"
 		"  --metrics: to display derived metrics of the ports, disabled by "
@@ -125,7 +151,7 @@ proc_info_usage(const char *prgname)
 /*
  * Parse the portmask provided at run time.
  */
-static int
+static int64_t
 parse_portmask(const char *portmask)
 {
 	char *end = NULL;
@@ -142,6 +168,71 @@ parse_portmask(const char *portmask)
 	return 0;
 }
 
+/*
+ *  * Parse the QID provided at run time.
+ **/
+static int
+parse_int(const char *id)
+{
+	char *end = NULL;
+	unsigned long val;
+
+	errno = 0;
+
+	/* parse hexadecimal string */
+	val = strtoul(id, &end, 10);
+	if ((id[0] == '\0') || (end == NULL) || (*end != '\0') ||
+			(errno != 0)) {
+		printf("%s ERROR parsing the QID\n", __func__);
+		return -1;
+	}
+
+	return val;
+}
+
+/*
+ * Parse the register address provided at run time.
+ */
+static int32_t
+parse_reg_addr(const char *addr)
+{
+	char *end = NULL;
+
+	errno = 0;
+
+	/* parse hexadecimal string */
+	reg_addr = strtoul(addr, &end, 16);
+	if ((addr[0] == '\0') || (end == NULL) || (*end != '\0') ||
+		(errno != 0)) {
+		printf("%s ERROR parsing the register address\n", __func__);
+		return -1;
+	}
+
+	if (reg_addr == 0)
+		return -1;
+
+	return reg_addr;
+}
+
+/*
+ *  * Parse the desc dump type provided at run time.
+ **/
+static int
+parse_desc_type(const char *type)
+{
+	if (!strcmp(type, "rx")) {
+		desc_type = RTE_PMD_QDMA_XDEBUG_DESC_C2H;
+	} else if (!strcmp(type, "tx")) {
+		desc_type = RTE_PMD_QDMA_XDEBUG_DESC_H2C;
+	} else if (!strcmp(type, "cmpt")) {
+		desc_type = RTE_PMD_QDMA_XDEBUG_DESC_CMPT;
+	} else {
+		printf("%s ERROR parsing the desc type\n", __func__);
+		return -1;
+	}
+	return 0;
+}
+
 /*
  * Parse ids value list into array
  */
@@ -206,11 +297,15 @@ proc_info_preparse_args(int argc, char **argv)
 static int
 proc_info_parse_args(int argc, char **argv)
 {
-	int opt;
+	int opt, ret;
 	int option_index;
 	char *prgname = argv[0];
 	static struct option long_option[] = {
 		{"stats", 0, NULL, 0},
+		{"qdevice", 0, NULL, 0},
+		{"qinfo", 0, NULL, 0},
+		{"reg-info", required_argument, NULL, 1},
+		{"desc-dump", required_argument, NULL, 1},
 		{"stats-reset", 0, NULL, 0},
 		{"xstats", 0, NULL, 0},
 		{"metrics", 0, NULL, 0},
@@ -232,7 +327,7 @@ proc_info_parse_args(int argc, char **argv)
 		proc_info_usage(prgname);
 
 	/* Parse command line */
-	while ((opt = getopt_long(argc, argv, "p:m",
+	while ((opt = getopt_long(argc, argv, "p:mq:gs:e:",
 			long_option, &option_index)) != EOF) {
 		switch (opt) {
 		/* portmask */
@@ -245,11 +340,46 @@ proc_info_parse_args(int argc, char **argv)
 		case 'm':
 			mem_info = 1;
 			break;
+		case 'g':
+			qdma_csr_info = 1;
+			break;
+		case 'q':
+			ret = parse_int(optarg);
+			if (ret < 0) {
+				printf("Invalid queue\n");
+				return -1;
+			}
+			qid = ret;
+			break;
+		case 's':
+			ret = parse_int(optarg);
+			if (ret < 0) {
+				printf("Invalid start value\n");
+				return -1;
+			}
+			start = ret;
+			break;
+		case 'e':
+			ret = parse_int(optarg);
+			if (ret < 0) {
+				printf("Invalid end value\n");
+				return -1;
+			}
+			end = ret;
+			break;
 		case 0:
 			/* Print stats */
 			if (!strncmp(long_option[option_index].name, "stats",
 					MAX_LONG_OPT_SZ))
 				enable_stats = 1;
+			/* Print qdma device */
+			if (!strncmp(long_option[option_index].name, "qdevice",
+					MAX_LONG_OPT_SZ))
+				qdma_device = 1;
+			/* Print queue context and queue Structures*/
+			if (!strncmp(long_option[option_index].name, "qinfo",
+					MAX_LONG_OPT_SZ))
+				queue_info = 1;
 			/* Print xstats */
 			else if (!strncmp(long_option[option_index].name, "xstats",
 					MAX_LONG_OPT_SZ))
@@ -309,6 +439,24 @@ proc_info_parse_args(int argc, char **argv)
 					return -1;
 				}
 
+			} else if (!strncmp(long_option[option_index].name,
+					"desc-dump",
+					MAX_LONG_OPT_SZ)) {
+				if (parse_desc_type(optarg) < 0) {
+					printf("desc-dump parse error.\n");
+					proc_info_usage(prgname);
+					return -1;
+				}
+				enable_desc_dump = 1;
+			} else if (!strncmp(long_option[option_index].name,
+					"reg-info",
+					MAX_LONG_OPT_SZ)) {
+				if (parse_reg_addr(optarg) < 0) {
+					printf("reg-info parse error.\n");
+					proc_info_usage(prgname);
+					return -1;
+				}
+				reg_info = 1;
 			}
 			break;
 		default:
@@ -1396,7 +1544,6 @@ main(int argc, char **argv)
 
 	if (mem_info) {
 		meminfo_display();
-		return 0;
 	}
 
 	nb_ports = rte_eth_dev_count_avail();
@@ -1412,7 +1559,7 @@ main(int argc, char **argv)
 	for (i = 0; i < RTE_MAX_ETHPORTS; i++) {
 
 		/* Skip if port is not in mask */
-		if ((enabled_port_mask & (1ul << i)) == 0)
+		if ((enabled_port_mask & ((uint64_t)1 << i)) == 0)
 			continue;
 
 		/* Skip if port is unused */
@@ -1434,7 +1581,18 @@ main(int argc, char **argv)
 						  nb_xstats_ids);
 		else if (enable_metrics)
 			metrics_display(i);
-
+		else if (qdma_csr_info)
+			rte_pmd_qdma_dbg_regdump(i);
+		else if (qdma_device)
+			rte_pmd_qdma_dbg_qdevice(i);
+		else if (queue_info)
+			rte_pmd_qdma_dbg_qinfo(i, qid);
+		else if (reg_info)
+			rte_pmd_qdma_dbg_reg_info_dump(i,
+				1, reg_addr);
+		else if (enable_desc_dump)
+			rte_pmd_qdma_dbg_qdesc(i, qid,
+				start, end, desc_type);
 	}
 
 	/* print port independent stats */
-- 
2.17.1

